Webserv – To‑Do List [MISE À JOUR Nov 19, 2025]

avancer projet : ~70-75%

Ordre recommandé (rapide -> long)
1) HTTP: entêtes
	- Server: WebServ à TOUTES les réponses ✅
	- Connection: close à TOUTES les réponses (pas de keep-alive) ✅
	- Date: optionnel; ✅ 
2) Erreurs: fallback pages par défaut (www/error/CODE.html) si non configurées ✅
3) Static: appliquer root/index par location avant la résolution du fichier ✅
4) Static: index par défaut si le chemin est un dossier ✅
5) Tests: 3 curl de base (200, 404, 405) ✅
6) Config: server_name + sélection via Host ✅
7) HTTP: Content-Length simple + 400 si incohérent ✅ (implémentée dans les réponses)
8) Config: client_max_body_size -> 413 ✅ - parsing implémenté dans ServerConf, validation à vérifier
9) Static: autoindex (listing) si activé ✅
10) Config: return (301/302) ✅ -
11) Méthodes: POST upload vers dossier configuré ✅ - POST: upload basique implémenté (handlePostRequest)
12) HTTP: Transfer-Encoding: chunked (déchunking) [EN COURS] - priorité: finir le déchunking et l'intégration avant CGI
13) CGI: implémenter un CGI simple [ ] - attendre POST/déchunking pour intégration
14) Réseau/IO: envois partiels, EAGAIN, timeouts, stress tests ✅ - pas de gestion EAGAIN/partial write

Exécution
- ✅ Fichier de configuration par défaut si aucun argument (ex: conf_file/default.conf)

Réseau / IO (non bloquant)
- ✅ Sockets non-bloquants + epoll unique
- ✅ Bases en place pour lecture/écriture (acceptClient, handleReadEvent, handleWriteEvent)
- ✅ Surveiller LECTURE ET ÉCRITURE simultanément: implémenter queue d'envoi pour gérer buffers d'envoi si écriture partielle
- ✅ Gérer envois partiels (write() retourne < bytes_à_envoyer), EAGAIN, et timeouts par client pour éviter les hangs
- ✅ Events géré via epoll (EPOLLIN pour clients)
- ✅ EPOLLOUT si buffers d'envoi pleins (pas d'implémentation actuellement)

HTTP Core
- ✅ Parsing des headers basique (HttpRequestHandler::parseHeader)
- ✅ Extraction method/uri/body
- [ ] Parser robuste: validation ligne de requête + CRLF strict + normalisation d'URI
- ✅ Gestion Content-Length: calculé pour chaque réponse
- [EN COURS] Transfer-Encoding: chunked (déchunking au parsing, priorité haute)
- ✅ Entêtes uniformes: Server + Connection: close partout
- ✅ Date (RFC1123) optionnel OU à supprimer
- ✅ Content-Type/MIME par extension
- ✅ 405 si méthode invalide
- ✅ 400 si Host manquant (HTTP/1.1)
- [ ] Sécuriser chemins: normalisation d'URI, anti path traversal (ex: /../../../etc/passwd)

Méthodes
- ✅ GET basique (fichiers statiques, getHtmlPage)
- ✅ DELETE (suppression de fichier, implémenté mais à valider)
- ✅ POST: upload basique implémenté (handlePostRequest) — multipart à améliorer si besoin
- [ ] PUT: vérifier si requis par le sujet (probablement non, mais validé pour 405 si non autorisé)

Fichiers statiques / Dossiers
- ✅ Autoindex (listing): field déclaré dans Location, génération HTML OK
- ✅ Index par défaut dans les dossiers (getHtmlPage gère index en dernier recours)
- ✅ Appliquer root/index par location (getHtmlPage)

Gestion des erreurs
- ✅ Pages d'erreur par défaut si non fournies (fallback www/error/CODE.html, handleError)
- ✅ Status line cohérente avec la page d'erreur
- ✅ Codes: 404, 405, 413, 500 exacts et cohérents
- [ ] client_max_body_size -> 413: parsing OK dans ServerConf.cpp, validation manquante dans HttpRequestHandler

Configuration (.conf)
- ✅ Parsing du .conf basique (ServerConf::parseConfigFile)
- ✅ server_name et sélection du bon serveur via l'en-tête Host: selection partielle à vérifier
- ✅ client_max_body_size: parsing implémenté avec support des unités (K, M, G)
- ✅ return (redirect 301/302): pas de parsing
- [ ] upload_store (ou équivalent): pas de parsing
- [ ] cgi_pass / mapping par extension (.php/.py): pas de parsing
- ✅ root/index/autoindex par location: parsing OK
- ✅ allowed_methods par location: parsing OK
- ✅ listen multi-ports: parsing OK

CGI
- [ ] Implémenter au moins un CGI (php-cgi ou python)
- [ ] fork/execve, pipes non bloquants, variables d'environnement CGI
- [ ] PATH_INFO, SCRIPT_FILENAME, QUERY_STRING, REQUEST_METHOD, etc.
- [ ] Déchunker la requête avant CGI; lire jusqu'à EOF si pas de Content-Length renvoyé
- [ ] Lancer le CGI dans le bon répertoire (cwd)
- [ ] Timeout pour éviter zombie CGI

Tests / Validation
- ✅ Tests curl basiques (200/404/405) probablement OK
- ✅ Tests complets (200/301/302/400/403/404/405/413/500) en cours de validation
- ✅ Vérifier entêtes: Server, Connection, Content-Length (et Date si implémentée)
- [ ] Stress tests (wrk/ab) + vérif non-blocage et EAGAIN handling
- [ ] Comparaison avec NGINX (entêtes et comportements)

Priorités immédiates
- 1) Implémenter buffer/état par client (map fd -> ClientState) pour permettre reads/writes partiels.
- 2) Finir le déchunking (Transfer-Encoding: chunked) -> priorité haute avant CGI.
- 3) Ajouter parsing `client_max_body_size` et validation -> renvoyer 413 si dépasse.
- 4) Finaliser l'upload multipart dans POST
- 5) Esquisser CGI minimal et tests locaux (php-cgi ou python) une fois POST/déchunking ok.