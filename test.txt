Parfait ! J'ai analys√© ton code. Le probl√®me est clair maintenant. Voici ce qui se passe :
üîç Diagnostic

Dans Server.cpp, ligne ~340-370, tu d√©tectes bien la limite d√©pass√©e et tu envoies une r√©ponse 413, MAIS :

if (maxBodySize > 0 && announcedLength >= maxBodySize)
{
    // Tu envoies la r√©ponse 413... ‚úÖ
    sendBuffers_[clientFd] = resp413.str();
    // ...
    return; // ‚ö†Ô∏è Tu retournes imm√©diatement
}

Le probl√®me : le client continue d'envoyer le body, mais ton serveur a d√©j√† quitt√© handleReadEvent(). Les donn√©es arrivent toujours sur la socket, mais tu ne les lis plus. R√©sultat ‚Üí connection reset.
‚úÖ Solution
Tu dois vider/ignorer le reste du body avant d'envoyer le 413. Voici les modifications :
1Ô∏è‚É£ Ajoute un flag dans Server.hpp

std::map<int, bool> clientsToClose_; // ‚úÖ AJOUT : marque les connexions √† fermer apr√®s envoi
std::map<int, size_t> clientBytesToIgnore_; // ‚úÖ AJOUT : combien de bytes ignorer
2Ô∏è‚É£ Modifie handleReadEvent() dans Server.cpp
Remplace la section de d√©tection du Content-Length (ligne ~340) par :
(fichier test.cpp)
3Ô∏è‚É£ Modifie handleSendEvent() pour fermer apr√®s 413

Dans Server.cpp, dans handleSendEvent(), tu as d√©j√† ce code (ligne ~650) :

if (offset >= buf.size())
{
    bool isTimeoutResponse = (buf.find("408 Request Timeout") != std::string::npos);
    bool is413Response = (buf.find("413 Payload Too Large") != std::string::npos);  // ‚úÖ D√©j√† l√†!

    sendBuffers_.erase(clientFd);
    sendOffsets_.erase(clientFd);
    clientSendStart_.erase(clientFd);
    clientBuffers_.erase(clientFd);

    if (isTimeoutResponse || is413Response)
    {
        close(clientFd);  // ‚úÖ PARFAIT - Ferme apr√®s l'envoi
        // ... cleanup ...
    }
}

C'est d√©j√† bon ! Tu fermes bien la connexion apr√®s l'envoi du 413.

üéØ R√©sum√© des changements

Ajoute 2 maps dans Server.hpp :

std::map<int, size_t> clientBytesToIgnore_;


Modifie handleReadEvent() pour :

D√©tecter le d√©passement d√®s la lecture du Content-Length
Continuer √† lire (et ignorer) les bytes exc√©dentaires
N'envoyer le 413 qu'une fois tout vid√©


Garde handleSendEvent() tel quel (tu fermes d√©j√† apr√®s 413 ‚úÖ)

üß™ Test
Avec ces changements :

‚úÖ Le serveur envoie HTTP/1.1 413 Payload Too Large
‚úÖ Une page d'erreur HTML s'affiche (pas "connection reset")
‚úÖ La console affiche le code 413 (pas une croix rouge)

Dis-moi si tu veux que je te montre les modifications exactes √† faire dans tes fichiers !